// MiniCppSem.cs                                              HDO, 2006-08-28
// -------------
// Semantic evaluator for table-driven top-down parsing.
// Generated by Coco-2 (PGT).
//=====================================|========================================

using System;
using System.Text;

using Lex = MiniCppLex;
using Syn = MiniCppSyn;

public class MiniCppSem {


  public const String MODULENAME = "MiniCppSem";

  public static void MiniCppSemMethod(Utils.ModuleAction action, out String moduleName) {
  //-----------------------------------|----------------------------------------
    moduleName = MODULENAME;
    switch (action) {
      case Utils.ModuleAction.getModuleName:
        return;
      case Utils.ModuleAction.initModule:
        break;
      case Utils.ModuleAction.resetModule:
        break;
      case Utils.ModuleAction.cleanupModule:
        return;
    } // switch
  } // MiniCppSemMethod


  // *** start of global SYN and SEM declarations from ATG ***
  
  private static Symbol curFuncSy  = null;
  private static int    loopLevel  = 0;
  
  private static void SemErr(String msg) {
    Errors.SemError(MiniCppLex.tokenLine, MiniCppLex.tokenCol, msg);
  } // SemErr
  

  // *** end of global SYN and SEM declarations from ATG ***

  

  private static void NT_MiniCpp() {
    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1: // SEM
          NameList.Init(true);
          SymTab.Init();

          break;
        case 2:
          NT_ConstDecl();
          break;
        case 3:
          NT_VarDefOrFuncDeclOrDef();
          break;
        case 4: // SEM
          if (!SymTab.MainFuncDefined())
            SemErr("no main func defined");

          break;
      } // switch
    } // for
  } // NT_MiniCpp

  private static void NT_ConstDecl() {
    Type t = null;
    Symbol sy = null;
    Stat s = null;
    int spix = 0;

    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1:
          NT_Type(out t);
          break;
        case 2:
          Lex.GETidentAttr(out spix);
          break;
        case 3: // SEM
          sy = SymTab.Insert(spix, Symbol.Kind.constKind,
                             t, false);

          break;
        case 4:
          NT_Init(out s, ref sy);
          break;
      } // switch
    } // for
  } // NT_ConstDecl

  private static void NT_Init(out Stat s,
                              ref Symbol sy) {
    int fact = 1, number = 0;
    s = null;

    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1: // SEM
          if (sy.type != Type.boolType)
            SemErr("invalid type");
          sy.val = 0;

          break;
        case 2: // SEM
          if (sy.type != Type.boolType)
            SemErr("invalid type");
          sy.val = 1;

          break;
        case 3: // SEM
          fact = -1;

          break;
        case 4:
          Lex.GETnumberAttr(out number);
          break;
        case 5: // SEM
          if (sy.type.IsPtrType()) {
            if (number != 0)
              SemErr("invalid value");
          } else if (sy.type.kind != Type.Kind.intKind)
            SemErr("invalid type");
          sy.val = fact * number;

          break;
        case 6: // SEM
          if (sy.kind == Symbol.Kind.varKind && loopLevel > 0)
            s = new AssignStat(new SrcPos(),
                  new VarOperand(sy),
                  new LitOperand(sy.type, sy.val));

          break;
      } // switch
    } // for
  } // NT_Init

  private static void NT_VarDefOrFuncDeclOrDef() {
    Type t = null;
    Symbol funcSy = null, sy = null, locSymbols = null;
    Stat statList = null, s = null;
    int spix = 0;
    bool ptr = false;

    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1:
          NT_Type(out t);
          break;
        case 2: // SEM
          ptr = true;

          break;
        case 3:
          Lex.GETidentAttr(out spix);
          break;
        case 4: // SEM
          sy = SymTab.Insert(spix, Symbol.Kind.varKind,
                             t, ptr);

          break;
        case 5:
          NT_VarDefRest(out s,        /*deliveres s = null*/
                      t, sy, ptr);
          break;
        case 6: // SEM
          funcSy = SymTab.Lookup(spix);
          if (funcSy == null)
            funcSy = SymTab.Insert(spix,
                            Symbol.Kind.funcKind, t, ptr);
          else if (funcSy.kind != Symbol.Kind.undefKind) {
            if (funcSy.kind == Symbol.Kind.funcKind &&
                funcSy.defined)
               SemErr("multiple function decl or def");
            else if (funcSy.kind != Symbol.Kind.funcKind) {
               SemErr("invalid redefinition");
               funcSy.kind = Symbol.Kind.undefKind;
            } // else
          } // else
          SymTab.EnterScope();
          ptr = false;

          break;
        case 7:
          NT_FormParList(funcSy);
          break;
        case 8: // SEM
          if (funcSy.kind == Symbol.Kind.funcKind) {
            if (funcSy.hadFuncDecl)
              SemErr("multiple function declaration");
            else {
              funcSy.hadFuncDecl = true;
              funcSy.funcDeclParList = SymTab.CurSymbols();
            } // else
          } // if
          SymTab.LeaveScope();

          break;
        case 9: // SEM
          funcSy.symbols = SymTab.CurSymbols();
          funcSy.FuncDef(); // do decl and def match?
          curFuncSy = funcSy;
          loopLevel = 0;

          break;
        case 10:
          NT_Block(out locSymbols,
                 out statList);
          break;
        case 11: // SEM
          funcSy.symbols  = locSymbols;
          funcSy.statList = statList;
          SymTab.LeaveScope();

          break;
      } // switch
    } // for
  } // NT_VarDefOrFuncDeclOrDef

  private static void NT_VarDef(out Stat s) {
    Type t = null;
    Symbol sy = null;
    int spix = 0;
    bool ptr = false;
    s = null;

    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1:
          NT_Type(out t);
          break;
        case 2: // SEM
          ptr = true;

          break;
        case 3:
          Lex.GETidentAttr(out spix);
          break;
        case 4: // SEM
          sy = SymTab.Insert(spix, Symbol.Kind.varKind,
                             t, ptr);

          break;
        case 5:
          NT_VarDefRest(out s, t, sy, ptr);
          break;
      } // switch
    } // for
  } // NT_VarDef

  private static void NT_VarDefRest(out Stat s,
                                    Type t,
                                    Symbol sy,
                                    bool ptr) {
    int spix = 0;
    Stat statList = null, s2 = null;
    s = null;

    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1:
          NT_Init(out statList,
                ref sy);
          break;
        case 2: // SEM
          sy.init = true;

          break;
        case 3: // SEM
          ptr = false;

          break;
        case 4: // SEM
          ptr = true;

          break;
        case 5:
          Lex.GETidentAttr(out spix);
          break;
        case 6: // SEM
          sy = SymTab.Insert(spix, Symbol.Kind.varKind,
                             t, ptr);

          break;
        case 7:
          NT_Init(out s2,
                ref sy);
          break;
        case 8: // SEM
          sy.init = true;
          if (statList == null)
            statList = s2;
          else { // append s2 to statList
            s = statList;
            while (s.next != null) {
              s = s.next;
            } // while
            s.next = s2;
          } // else
          

          break;
        case 9: // SEM
          ptr = false;

          break;
        case 10: // SEM
          s = statList;

          break;
      } // switch
    } // for
  } // NT_VarDefRest

  private static void NT_FormParList(Symbol funcSy) {
    int spix = 0; bool ptr = false;
    Type t = null;

    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1:
          NT_Type(out t);
          break;
        case 2: // SEM
          if (t.kind != Type.Kind.voidKind)
            SemErr("void expected");

          break;
        case 3: // SEM
          ptr = true;

          break;
        case 4:
          Lex.GETidentAttr(out spix);
          break;
        case 5: // SEM
          if (ptr)
            SemErr("pointer to array not supported");
          ptr = true;

          break;
        case 6: // SEM
          SymTab.Insert(spix, Symbol.Kind.parKind,
                        t, ptr);
          ptr = false;

          break;
        case 7:
          NT_Type(out t);
          break;
        case 8: // SEM
          ptr = true;

          break;
        case 9:
          Lex.GETidentAttr(out spix);
          break;
        case 10: // SEM
          if (ptr)
            SemErr("pointer to array not supported");
          ptr = true;

          break;
        case 11: // SEM
          SymTab.Insert(spix, Symbol.Kind.parKind,
                        t, ptr);
          ptr = false;

          break;
      } // switch
    } // for
  } // NT_FormParList

  private static void NT_Type(out Type t) {
    t = null;

    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1: // SEM
          t = Type.voidType;

          break;
        case 2: // SEM
          t = Type.boolType;

          break;
        case 3: // SEM
          t = Type.intType;

          break;
      } // switch
    } // for
  } // NT_Type

  private static void NT_Block(out Symbol locSymbols,
                               out Stat   statList) {
    locSymbols = null;
    Stat last = null, s = null;
    statList = null;

    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1:
          NT_ConstDecl();
          break;
        case 2:
          NT_VarDef(out s);
          break;
        case 3:
          NT_Stat(out s);
          break;
        case 4: // SEM
          if (s != null) {
            if (statList == null)
              statList = s;
            else // statList != null
              last.next = s;
            while (s.next != null) {
              s = s.next;
            } // while
            last = s;
            s = null;
          } // if

          break;
        case 5: // SEM
          locSymbols = SymTab.CurSymbols();

          break;
      } // switch
    } // for
  } // NT_Block

  private static void NT_Stat(out Stat s) {
    Symbol locSymbols = null;
    Stat statList = null;
    SrcPos sp = null;
    s = null;

    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1:
          NT_IncDecAssignOrCallStat(out s);
          break;
        case 2:
          NT_IfStat(out s);
          break;
        case 3:
          NT_WhileStat(out s);
          break;
        case 4:
          NT_SwitchStat(out s);
          break;
        case 5:
          NT_BreakStat(out s);
          break;
        case 6:
          NT_InputStat(out s);
          break;
        case 7:
          NT_OutputStat(out s);
          break;
        case 8:
          NT_DeleteStat(out s);
          break;
        case 9:
          NT_ReturnStat(out s);
          break;
        case 10: // SEM
          sp = new SrcPos();

          break;
        case 11:
          NT_Block(out locSymbols,
                 out statList);
          break;
        case 12: // SEM
          s = new BlockStat(sp, statList);

          break;
        case 13: // SEM
          s = new EmptyStat(null);

          break;
      } // switch
    } // for
  } // NT_Stat

  private static void NT_IncDecAssignOrCallStat(out Stat s) {
    int spix = 0;
    Symbol sy = null;
    Expr lhs = null, e = null;
    SrcPos sp = null;
    s = null;

    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1:
          Lex.GETidentAttr(out spix);
          break;
        case 2: // SEM
          sy = SymTab.SymbolOf(spix, Symbol.Kind.varKind,
                                     Symbol.Kind.parKind,
                                     Symbol.Kind.funcKind);

          break;
        case 3: // SEM
          s = new IncStat(sp, new VarOperand(sy));

          break;
        case 4: // SEM
          s = new DecStat(sp, new VarOperand(sy));

          break;
        case 5: // SEM
          lhs = new VarOperand(sy);

          break;
        case 6: // SEM
          sp = new SrcPos();

          break;
        case 7:
          NT_Expr(out e);
          break;
        case 8: // SEM
          lhs = new ArrIdxOperator(sp, new VarOperand(sy), e);

          break;
        case 9: // SEM
          sp = new SrcPos();

          break;
        case 10:
          NT_Expr(out e);
          break;
        case 11: // SEM
          s = new AssignStat(sp, lhs, e);

          break;
        case 12: // SEM
          sp = new SrcPos();

          break;
        case 13:
          NT_ActParList(out e);
          break;
        case 14: // SEM
          s = new CallStat(sp, sy, e);

          break;
      } // switch
    } // for
  } // NT_IncDecAssignOrCallStat

  private static void NT_ActParList(out Expr apl) {
    Expr e = null, last = null;
    apl = null;

    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1:
          NT_Expr(out e);
          break;
        case 2: // SEM
          apl = e;
          last = apl;

          break;
        case 3:
          NT_Expr(out e);
          break;
        case 4: // SEM
          last.next = e;
          last = e;

          break;
      } // switch
    } // for
  } // NT_ActParList

  private static void NT_IfStat(out Stat s) {
    Expr e = null;
    Stat thenStat = null, elseStat = null;
    SrcPos sp = null;
    s = null;

    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1: // SEM
          sp = new SrcPos();

          break;
        case 2:
          NT_Expr(out e);
          break;
        case 3:
          NT_Stat(out thenStat);
          break;
        case 4:
          NT_Stat(out elseStat);
          break;
        case 5: // SEM
          s = new IfStat(sp, e, thenStat, elseStat);

          break;
      } // switch
    } // for
  } // NT_IfStat

  private static void NT_WhileStat(out Stat s) {
    Expr e = null;
    Stat body = null;
    SrcPos sp = null;
    s = null;

    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1: // SEM
          sp = new SrcPos();

          break;
        case 2:
          NT_Expr(out e);
          break;
        case 3: // SEM
          loopLevel++;

          break;
        case 4:
          NT_Stat(out body);
          break;
        case 5: // SEM
          s = new WhileStat(sp, e, body);
          loopLevel--;

          break;
      } // switch
    } // for
  } // NT_WhileStat

  private static void NT_SwitchStat(out Stat s) {
    Expr e = null; s = null;
    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1:
          NT_Expr(out e);
          break;
        case 2: // SEM
          loopLevel++;
          break;
        case 3:
          NT_CaseList(out s);
          break;
        case 4:
          NT_DefaultPart(out s);
          break;
        case 5: // SEM
          loopLevel--;
          break;
      } // switch
    } // for
  } // NT_SwitchStat

  private static void NT_CaseList(out Stat s) {
    int val = 0; s = null;
    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1:
          Lex.GETnumberAttr(out val);
          break;
        case 2:
          NT_Stat(out s);
          break;
      } // switch
    } // for
  } // NT_CaseList

  private static void NT_DefaultPart(out Stat s) {
    s = null;
    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1:
          NT_Stat(out s);
          break;
        case 2:
          NT_Stat(out s);
          break;
      } // switch
    } // for
  } // NT_DefaultPart

  private static void NT_BreakStat(out Stat s) {
    s = null;

    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1: // SEM
          if (loopLevel <= 0)
            SemErr("no loop around");
          s = new BreakStat(new SrcPos());

          break;
      } // switch
    } // for
  } // NT_BreakStat

  private static void NT_InputStat(out Stat s) {
    int spix = 0;
    Symbol sy = null;
    SrcPos sp = null;
    s = null;

    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1: // SEM
          sp = new SrcPos();

          break;
        case 2:
          Lex.GETidentAttr(out spix);
          break;
        case 3: // SEM
          sy = SymTab.SymbolOf(spix, Symbol.Kind.varKind,
                                     Symbol.Kind.parKind);
          s = new InputStat(sp, new VarOperand(sy));

          break;
      } // switch
    } // for
  } // NT_InputStat

  private static void NT_OutputStat(out Stat s) {
    Expr e = null;
    String str = null;
    SrcPos sp = null;
    System.Collections.ArrayList values =
      new System.Collections.ArrayList();
    s = null;

    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1: // SEM
          sp = new SrcPos();

          break;
        case 2:
          NT_Expr(out e);
          break;
        case 3: // SEM
          values.Add(e);

          break;
        case 4:
          Lex.GETstringAttr(out str);
          break;
        case 5: // SEM
          values.Add(str);

          break;
        case 6: // SEM
          values.Add("\n");

          break;
        case 7:
          NT_Expr(out e);
          break;
        case 8: // SEM
          values.Add(e);

          break;
        case 9:
          Lex.GETstringAttr(out str);
          break;
        case 10: // SEM
          values.Add(str);

          break;
        case 11: // SEM
          values.Add("\n");

          break;
        case 12: // SEM
          s = new OutputStat(sp, values);

          break;
      } // switch
    } // for
  } // NT_OutputStat

  private static void NT_DeleteStat(out Stat s) {
    int spix = 0;
    Symbol sy = null;
    SrcPos sp = null;
    s = null;

    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1: // SEM
          sp = new SrcPos();

          break;
        case 2:
          Lex.GETidentAttr(out spix);
          break;
        case 3: // SEM
          sy = SymTab.SymbolOf(spix, Symbol.Kind.varKind,
                                     Symbol.Kind.parKind);
          s = new DeleteStat(sp, new VarOperand(sy));

          break;
      } // switch
    } // for
  } // NT_DeleteStat

  private static void NT_ReturnStat(out Stat s) {
    Expr e = null;
    SrcPos sp = null;
    s = null;

    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1: // SEM
          sp = new SrcPos();

          break;
        case 2:
          NT_Expr(out e);
          break;
        case 3: // SEM
          s = new ReturnStat(sp, curFuncSy, e);

          break;
      } // switch
    } // for
  } // NT_ReturnStat

  private static void NT_Expr(out Expr e) {
    e = null;

    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1:
          NT_OrExpr(out e);
          break;
      } // switch
    } // for
  } // NT_Expr

  private static void NT_OrExpr(out Expr oe) {
    Expr ae = null;
    SrcPos sp = null;
    BinaryOperator.Operation binOp =
      BinaryOperator.Operation.undefOp;
    oe = null;

    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1:
          NT_AndExpr(out ae);
          break;
        case 2: // SEM
          oe = ae;

          break;
        case 3: // SEM
          binOp = BinaryOperator.Operation.orOp;
          sp = new SrcPos();

          break;
        case 4:
          NT_AndExpr(out ae);
          break;
        case 5: // SEM
          oe = new BinaryOperator(sp, binOp, oe, ae);

          break;
      } // switch
    } // for
  } // NT_OrExpr

  private static void NT_AndExpr(out Expr ae) {
    Expr re = null;
    SrcPos sp = null;
    BinaryOperator.Operation binOp =
      BinaryOperator.Operation.undefOp;
    ae = null;

    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1:
          NT_RelExpr(out re);
          break;
        case 2: // SEM
          ae = re;

          break;
        case 3: // SEM
          binOp = BinaryOperator.Operation.andOp;
          sp = new SrcPos();

          break;
        case 4:
          NT_RelExpr(out re);
          break;
        case 5: // SEM
          ae = new BinaryOperator(sp, binOp, ae, re);

          break;
      } // switch
    } // for
  } // NT_AndExpr

  private static void NT_RelExpr(out Expr re) {
    Expr se = null;
    SrcPos sp = null;
    BinaryOperator.Operation binOp =
      BinaryOperator.Operation.undefOp;
    re = null;

    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1:
          NT_SimpleExpr(out se);
          break;
        case 2: // SEM
          re = se;

          break;
        case 3: // SEM
          binOp = BinaryOperator.Operation.eqOp;
          sp = new SrcPos();

          break;
        case 4: // SEM
          binOp = BinaryOperator.Operation.neOp;
          sp = new SrcPos();

          break;
        case 5: // SEM
          binOp = BinaryOperator.Operation.ltOp;
          sp = new SrcPos();

          break;
        case 6: // SEM
          binOp = BinaryOperator.Operation.leOp;
          sp = new SrcPos();

          break;
        case 7: // SEM
          binOp = BinaryOperator.Operation.gtOp;
          sp = new SrcPos();

          break;
        case 8: // SEM
          binOp = BinaryOperator.Operation.geOp;
          sp = new SrcPos();

          break;
        case 9:
          NT_SimpleExpr(out se);
          break;
        case 10: // SEM
          re = new BinaryOperator(sp, binOp, re, se);

          break;
      } // switch
    } // for
  } // NT_RelExpr

  private static void NT_SimpleExpr(out Expr se) {
    Expr t = null;
    SrcPos sp = null;
    UnaryOperator.Operation unOp =
      UnaryOperator.Operation.undefOp;
    BinaryOperator.Operation binOp =
      BinaryOperator.Operation.undefOp;
    se = null;

    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1: // SEM
          unOp = UnaryOperator.Operation.posOp;
          sp = new SrcPos();

          break;
        case 2: // SEM
          unOp = UnaryOperator.Operation.negOp;
          sp = new SrcPos();

          break;
        case 3:
          NT_Term(out t);
          break;
        case 4: // SEM
          if (unOp != UnaryOperator.Operation.undefOp)
            se = new UnaryOperator(sp, unOp, t);
          else
            se = t;

          break;
        case 5: // SEM
          binOp = BinaryOperator.Operation.addOp;
          sp = new SrcPos();

          break;
        case 6: // SEM
          binOp = BinaryOperator.Operation.subOp;
          sp = new SrcPos();

          break;
        case 7:
          NT_Term(out t);
          break;
        case 8: // SEM
          se = new BinaryOperator(sp, binOp, se, t);

          break;
      } // switch
    } // for
  } // NT_SimpleExpr

  private static void NT_Term(out Expr t) {
    Expr f = null;
    SrcPos sp = null;
    BinaryOperator.Operation binOp =
      BinaryOperator.Operation.undefOp;
    t = null;

    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1:
          NT_NotFact(out f);
          break;
        case 2: // SEM
          t = f;

          break;
        case 3: // SEM
          binOp = BinaryOperator.Operation.mulOp;
          sp = new SrcPos();

          break;
        case 4: // SEM
          binOp = BinaryOperator.Operation.divOp;
          sp = new SrcPos();

          break;
        case 5: // SEM
          binOp = BinaryOperator.Operation.modOp;
          sp = new SrcPos();

          break;
        case 6:
          NT_NotFact(out f);
          break;
        case 7: // SEM
          t = new BinaryOperator(sp, binOp, t, f);

          break;
      } // switch
    } // for
  } // NT_Term

  private static void NT_NotFact(out Expr nf) {
    SrcPos sp = null;
    bool hasNot = false;
    nf = null;

    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1: // SEM
          hasNot = true;
          sp = new SrcPos();

          break;
        case 2:
          NT_Fact(out nf);
          break;
        case 3: // SEM
          if (hasNot)
            nf = new UnaryOperator(sp,
              UnaryOperator.Operation.notOp, nf);

          break;
      } // switch
    } // for
  } // NT_NotFact

  private static void NT_Fact(out Expr f) {
    Expr e = null;
    SrcPos sp = null;
    Symbol sy = null;
    int spix = 0; int number = 0;
    Type t = null;
    f = null;

    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1: // SEM
          f = new LitOperand(Type.boolType, 0);

          break;
        case 2: // SEM
          f = new LitOperand(Type.boolType, 1);

          break;
        case 3:
          Lex.GETnumberAttr(out number);
          break;
        case 4: // SEM
          f = new LitOperand(Type.intType, number);

          break;
        case 5:
          Lex.GETidentAttr(out spix);
          break;
        case 6: // SEM
          sp = new SrcPos();

          break;
        case 7: // SEM
          sy = SymTab.SymbolOf(spix, Symbol.Kind.constKind,
                                     Symbol.Kind.varKind,
                                     Symbol.Kind.parKind);
          f = new VarOperand(sy);

          break;
        case 8: // SEM
          sy = SymTab.SymbolOf(spix, Symbol.Kind.varKind,
                                     Symbol.Kind.parKind);

          break;
        case 9: // SEM
          sp = new SrcPos();

          break;
        case 10:
          NT_Expr(out e);
          break;
        case 11: // SEM
          f = new ArrIdxOperator(sp, new VarOperand(sy), e);

          break;
        case 12: // SEM
          sy = SymTab.SymbolOf(spix, Symbol.Kind.funcKind);

          break;
        case 13:
          NT_ActParList(out e);
          break;
        case 14: // SEM
          f = new FuncCallOperator(sp, sy, e);

          break;
        case 15: // SEM
          sp = new SrcPos();

          break;
        case 16:
          NT_Type(out t);
          break;
        case 17:
          NT_Expr(out e);
          break;
        case 18: // SEM
          f = new NewOperator(sp, t, e);

          break;
        case 19:
          NT_Expr(out e);
          break;
        case 20: // SEM
          f = e;

          break;
      } // switch
    } // for
  } // NT_Fact


  public delegate void PragmaMethod();
  public static PragmaMethod[] pragmaMethods = {
      // none
    };


  public static void StartSem() {
  //-----------------------------------|----------------------------------------
    for (;;) {
      switch (Syn.Interpret()) {
        case 0:
          return;
        case 1:
          NT_MiniCpp();
          break;
      } // switch
    } // for
  } // StartSem

    
} // MiniCppSem

// End of MiniCppSem.cs
//=====================================|========================================