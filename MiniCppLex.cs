// MiniCppLex.cs                                              HDO, 2006-08-28
// -------------
// Lexical analyzer (finite-state machine interpreter).
// Generated by Coco-2 (SG).
//=====================================|========================================

#undef TEST_Lex

using System;
using System.Collections;
using System.Collections.Specialized;
using System.IO;
using System.Text;

public class MiniCppLex {

  public const String MODULENAME = "MiniCppLex";
  public const int    EOFSPIX    = 1;

  public static TextReader src;

  // --- token information ---
  public static int    token;               // current token
  public static int    tokenLine, tokenCol; // position of current token
  public static String tokenStr;            // token string recognized

  // --- current char. info, for "power users" only ---
  public static char   curCh;               // current input character
  public static int    curLine, curCol;     // position of curCh


  public static void MiniCppLexMethod(Utils.ModuleAction action, out String moduleName) {
  //-----------------------------------|----------------------------------------
    moduleName = MODULENAME;
    switch (action) {
      case Utils.ModuleAction.getModuleName:
        return;
      case Utils.ModuleAction.initModule:
        caseSensitive = true;
        lt            = new LexicalTable();
        tokenStrArr   = new char[256];
        kwHt          = CreateHashtable();
        nHt           = CreateHashtable();
        nl            = new ArrayList();
        break;
      case Utils.ModuleAction.resetModule:
        kwHt.Clear();
        nHt.Clear();
        nl.Clear();
        break;
      case Utils.ModuleAction.cleanupModule:
        lt            = null;
        tokenStrArr   = null;
        kwHt          = null;
        nHt           = null;
        nl            = null;
        break;
    } // switch
  } // MiniCppLexMethod

  private static  Hashtable CreateHashtable() {
    if (caseSensitive)
      return new Hashtable();
    else
      return CollectionsUtil.CreateCaseInsensitiveHashtable();
  } // CreateHashtable


  public static void InitLex() {
  //-----------------------------------|----------------------------------------
    // --- initialize keyword hash table  ---
    kwHt.Clear();
    EnterKeyword(  1, "bool");
    EnterKeyword(  2, "break");
    EnterKeyword(  3, "cin");
    EnterKeyword(  4, "const");
    EnterKeyword(  5, "cout");
    EnterKeyword(  6, "delete");
    EnterKeyword(  7, "else");
    EnterKeyword(  8, "endl");
    EnterKeyword(  9, "false");
    EnterKeyword( 10, "if");
    EnterKeyword( 11, "int");
    EnterKeyword( 12, "new");
    EnterKeyword( 13, "return");
    EnterKeyword( 14, "true");
    EnterKeyword( 15, "void");
    EnterKeyword( 16, "while");
    // --- initialize name data structures  ---
    nHt.Clear();
    nl.Clear();
    nl.Add("");      // so spix = 0 is the empty string
    nl.Add("!EOF!"); // so EOFSPIX = 1
    // --- (re)set global data ---
    curLineStr  = "";
    curCh       = ' ';
    curLine     = 0;
    curCol      = 2;
    tokenStr    = null;
    token       = 0;
    tokenCol    = 0;
    tokenLine   = 0;
    tokenStrLen = 0;
    pendingEOLs = 0;
    apxLen      = pendingEOLs; // to prevent warning
  } // InitLex

  private static void EnterKeyword(int token, String keyword) {
    kwHt.Add(keyword, token);
  } // EnterKeyword


  // *** start of global LEX declarations from ATG ***
  
  // *** end of global LEX declarations from ATG ***


  public static bool caseSensitive;

  private class LexicalTable {
    public int   header = 5;
    public int[] startTab = {
          0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
          0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
          0, 30, 27,  0,  0,  4, 15,  0,  7,  8,  2, 31, 23, 32,  0,  3,
         26, 26, 26, 26, 26, 26, 26, 26, 26, 26,  0, 24, 33, 34, 35,  0,
          0, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
         25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,  9,  0, 10,  0, 25,
          0, 29, 29, 29, 29, 29, 29, 25, 29, 29, 25, 29, 29, 25, 29, 29,
         25, 25, 29, 29, 29, 29, 29, 29, 25, 25, 25, 11, 13, 12,  0,  0,
          0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
          0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
          0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
          0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
          0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
          0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
          0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
          0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0
      };
    public Sets.Set256 ignoredChars = new Sets.Set256(
         0x0600, 0x0000, 0x0001
      );
    public Sets.Set256 commentStart = new Sets.Set256(
         0x0000, 0x0000, 0x8000
      );
    public Sets.Set256[] cls = {
        new Sets.Set256( 0x0000, 0x0000, 0x0000, 0x0000, 0xfffe, 0x87ff, 0xfffe, 0x07ff),
        new Sets.Set256( 0x0000, 0x0000, 0x0000, 0x03ff),
        new Sets.Set256( 0x0000, 0x0000, 0xfffb, 0xffff, 0xffff, 0xffff, 0xffff, 0x7fff),
        new Sets.Set256( 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xdb7e, 0x00fc),
        new Sets.Set256( 0x0000, 0x0000, 0x0000, 0x0000, 0xfffe, 0x87ff, 0x2480, 0x0703)
      };
  } // LexicalTable

  private static LexicalTable lt;
  private static Hashtable    kwHt;  // hash table for keywords: string -> token 
  private static Hashtable    nHt;   // hash table for names: string -> null 
  private static ArrayList    nl;    // name list  for names, index is spix

  private static String curLineStr;  // current source line
  private static char[] tokenStrArr; // token string in an array
  private static int    tokenStrLen; // length of token string in tokenStrArr
  private static int    state;       // current automaton state
  private static int    apxLen;      // length of appendix in token string
  private static int    pendingEOLs; // nr of EOLs found in comment

  // --- to save and restore scanner state ---
  private static char   savedCh;
  private static int    savedCol, savedLine;

  private static void SaveScannerState() {
    savedCh      = curCh;
    savedCol     = curCol;
    savedLine    = curLine;
  } // SaveScannerState

  private static void RestoreScannerState() {
    tokenStrLen -= apxLen;
    apxLen       = 0;
    curCh        = savedCh;
    curCol       = savedCol;
    curLine      = savedLine;
  } // RestoreScannerState


  public static void NextCh() {
  //-----------------------------------|----------------------------------------
    for (;;) {
      
      if (curCol < curLineStr.Length) {         // within line
        curCol++;
        curCh = curLineStr[curCol - 1];
        return;
      } else if (curCol == curLineStr.Length) { // end of line
        curCol++;
        curCh = Utils.LF; // to separate lines
        return;
      } else { // curCol > curLineStr.Length
        curLineStr = src.ReadLine();
        curLine++;
        curCol = 0;
        if (curLineStr == null) {               // end of file
          curLineStr = "";
          curCh = Utils.EF;
          return;
        } // if
      } // else
    } // for
  } // NextCh


  private static void CommentErr() {
    Errors.LexError(curLine, curCol, "end of file in comment");
  } // CommentErr

  private static bool Comment() {
    
    
    SaveScannerState();
    // --- from '/' '/' to Utils.LF ---
    if (curCh == '/') {
      NextCh();
      if (curCh == '/') {
        NextCh();
        for (;;)
          switch (curCh) {
            case Utils.LF:
              NextCh();
              return true;
            case Utils.EF:
              CommentErr();
              return true;
            default:
              NextCh();
              break;
          } // switch
      } else
        RestoreScannerState();
    } // if
    // --- from '/' '*' to '*' '/' ---
    if (curCh == '/') {
      NextCh();
      if (curCh == '*') {
        NextCh();
        for (;;)
          switch (curCh) {
            case '*':
              NextCh();
              if (curCh == '/') {
                NextCh();
                return true;
              } // if
              break;
            case Utils.EF:
              CommentErr();
              return true;
            default:
              NextCh();
              break;
          } // switch
      } else
        RestoreScannerState();
    } // if
    return false;
  } // Comment

  private static void HandleLexErr() {
    Errors.LexError(curLine, curCol, 
                    "invalid character '{0}' (hex {1:X})", curCh, (int)curCh);
    if (apxLen > 0)
      RestoreScannerState();
  } // HandleLexErr


  public static void GetToken() {
  //-----------------------------------|----------------------------------------
    token = -1;
    tokenStr = null;
    do {
      // --- skip ignored chars and comments ---
      for (;;) {
        while (Sets.member(curCh, lt.ignoredChars))
          NextCh();
        if (!Sets.member(curCh, lt.commentStart))
          break;
        if (!Comment())
          break;
      } // for
      // --- scan for next token ---
      tokenLine   = curLine;
      tokenCol    = curCol;
      tokenStrLen = 0;
      apxLen      = 0;
      state = (curCh == Utils.EF) ? 1 : lt.startTab[curCh];
      for (;;) {
        tokenStrArr[tokenStrLen++]= curCh;
        NextCh();
        switch (state) {
          case 0:
            Errors.LexError(tokenLine, tokenCol, "invalid token start");
            break;
          case 1:
            token = 0;
            tokenStrLen = 0;
            break;                      // EOF recognized
          case 2:
            token = 19;
            break;                      // '*' recognized
          case 3:
            token = 20;
            break;                      // '/' recognized
          case 4:
            token = 21;
            break;                      // '%' recognized
          case 5:
            token = 22;
            break;                      // '++' recognized
          case 6:
            token = 23;
            break;                      // '--' recognized
          case 7:
            token = 24;
            break;                      // '(' recognized
          case 8:
            token = 25;
            break;                      // ')' recognized
          case 9:
            token = 26;
            break;                      // '[' recognized
          case 10:
            token = 27;
            break;                      // ']' recognized
          case 11:
            token = 28;
            break;                      // '{' recognized
          case 12:
            token = 29;
            break;                      // '}' recognized
          case 13:
            if (curCh == '|') {
              state = 14;
              continue;
            } // if
            else {
              HandleLexErr();
              break;
            } // else
          case 14:
            token = 31;
            break;                      // '||' recognized
          case 15:
            if (curCh == '&') {
              state = 16;
              continue;
            } // if
            else {
              HandleLexErr();
              break;
            } // else
          case 16:
            token = 32;
            break;                      // '&&' recognized
          case 17:
            token = 33;
            break;                      // '==' recognized
          case 18:
            token = 34;
            break;                      // '!=' recognized
          case 19:
            token = 36;
            break;                      // '<=' recognized
          case 20:
            token = 38;
            break;                      // '>=' recognized
          case 21:
            token = 39;
            break;                      // '<<' recognized
          case 22:
            token = 40;
            break;                      // '>>' recognized
          case 23:
            token = 41;
            break;                      // ',' recognized
          case 24:
            token = 43;
            break;                      // ';' recognized
          case 25:
            if (Sets.member(curCh, lt.cls[0])) {
              state = 25;
              continue;
            } // if
            else if (Sets.member(curCh, lt.cls[1])) {
              state = 25;
              continue;
            } // if
            else {
              token = KeywordCheck();
              if (token >= 0)
                break;                  // keyword recognized
              token = 44;
              break;                    // ident recognized
            } // else
          case 26:
            if (Sets.member(curCh, lt.cls[1])) {
              state = 26;
              continue;
            } // if
            else {
              token = 45;
              break;                    // number recognized
            } // else
          case 27:
            if (Sets.member(curCh, lt.cls[2])) {
              state = 27;
              continue;
            } // if
            else if (curCh == '\"') {
              state = 28;
              continue;
            } // if
            else {
              HandleLexErr();
              break;
            } // else
          case 28:
            token = 46;
            break;                      // string recognized
          case 29:
            if (Sets.member(curCh, lt.cls[1])) {
              state = 25;
              continue;
            } // if
            else if (Sets.member(curCh, lt.cls[3])) {
              state = 29;
              continue;
            } // if
            else if (Sets.member(curCh, lt.cls[4])) {
              state = 25;
              continue;
            } // if
            else {
              token = KeywordCheck();
              if (token >= 0)
                break;                  // keyword recognized
              token = 44;
              break;                    // ident recognized
            } // else
          case 30:
            if (curCh == '=') {
              state = 18;
              continue;
            } // if
            else {
              token = 30;
              break;                    // '!' recognized
            } // else
          case 31:
            if (curCh == '+') {
              state = 5;
              continue;
            } // if
            else {
              token = 17;
              break;                    // '+' recognized
            } // else
          case 32:
            if (curCh == '-') {
              state = 6;
              continue;
            } // if
            else {
              token = 18;
              break;                    // '-' recognized
            } // else
          case 33:
            if (curCh == '<') {
              state = 21;
              continue;
            } // if
            else if (curCh == '=') {
              state = 19;
              continue;
            } // if
            else {
              token = 35;
              break;                    // '<' recognized
            } // else
          case 34:
            if (curCh == '=') {
              state = 17;
              continue;
            } // if
            else {
              token = 42;
              break;                    // '=' recognized
            } // else
          case 35:
            if (curCh == '=') {
              state = 20;
              continue;
            } // if
            else if (curCh == '>') {
              state = 22;
              continue;
            } // if
            else {
              token = 37;
              break;                    // '>' recognized
            } // else
        } // switch
        break;
      } // for
    } while (token < 0);
    if (tokenStr == null)
      tokenStr = new String(tokenStrArr, 0, tokenStrLen);
  } // GetToken

  private static int KeywordCheck() {
    tokenStr = new String(tokenStrArr, 0, tokenStrLen - apxLen);
    Object token = kwHt[tokenStr];
    return (token == null) ? -1 : (int)token;
  } // KeywordCheck


  public static int Hash(String s) {
  //-----------------------------------|----------------------------------------
    Object spix = nHt[s];
    if (spix == null) {
      if (caseSensitive)
        nl.Add(s);
      else
        nl.Add(s.ToUpper());
      spix   = nl.Count - 1;
      nHt[s] = spix;
    } // if
    return (int)spix;
  } // Hash
  
  
  public static String HashedStr(int spix) {
  //-----------------------------------|----------------------------------------
    return (String)nl[spix];
  } // HashedStr


  public static void GETidentAttr(out int spix) {
    spix = NameList.SpixOf(tokenStr);

  } // GETidentAttr
  
  public static void GETnumberAttr(out int val) {
    val = Convert.ToInt32(tokenStr);

  } // GETnumberAttr
  
  public static void GETstringAttr(out String str) {
    str = tokenStr.Substring(1, tokenStr.Length - 2);

  } // GETstringAttr

} // MiniCppLex

// End of MiniCppLex.cs
//=====================================|========================================